#include <stdio.h>
#include <tgmath.h>
#include <real.h>

#include <co/array.h>
#include <co/err.h>
#include <co/he.h>
#include <co/memory.h>
#include <co/surface.h>
#include <co/vec.h>
#include <co/y.h>

#define FMT CO_REAL_OUT

enum {
  X, Y, Z
};
static const char me[] = "surface/vtk";
static const int M = 1000000;

int
main(int argc, const char **argv)
{
  Surface *surface;
  He *he;
  real *x, *y, *z, *u, *v, *w, *color;
  int n, nx, ny, nz, nv, i, j, k, l;
  real V, Lx, Ly, Lz, lx, ly, lz, hx, hy, hz, d, x0, y0, z0;
  real frac;
  frac = 0.1;

  err_set_ignore();
  y_inif(stdin, &he, &x, &y, &z);
  nv = he_nv(he);

  lx = array_min(nv, x);
  ly = array_min(nv, y);
  lz = array_min(nv, z);
  hx = array_max(nv, x);
  hy = array_max(nv, y);
  hz = array_max(nv, z);

  Lx = hx - lx;
  Ly = hy - lz;
  Lz = hz - ly;

  lx -= frac*Lx;
  ly -= frac*Ly;
  lz -= frac*Lz;

  hx += frac*Lx;
  hy += frac*Ly;
  hz += frac*Lz;

  MSG("l: %g %g %g", lx, ly, lz);
  MSG("h: %g %g %g", hx, hy, hz);

  real clo[3] = { lx - frac*Lx, ly - frac*Lx, lz - frac*Lx };
  real chi[3] = { hx + frac*Lx, hy + frac*Lx, hz + frac*Lx };
  surface_ini(clo, chi, frac*Lx, &surface);
  surface_update(surface, he, x, y, z);

  V = (hx - lx) * (hy - ly) * (hz - lz);
  d = pow(V/M, 1.0/3);
  nx = (int)( (hx - lx) / d );
  ny = (int)( (hy - ly) / d );
  nz = (int)( (hz - lz) / d );
  n = nx * ny * nz;
  MSG("n: %d %d %d %d", n, nx, ny, nz);
  MALLOC(n, &u);
  MALLOC(n, &v);
  MALLOC(n, &w);
  CALLOC(n, &color);
  l = 0;
  for (k = 0; k < nz; k++)
    for (j = 0; j < ny; j++)
      for (i = 0; i < nx; i++) {
	x0 = lx + d * i;
	y0 = ly + d * j;
	z0 = lz + d * k;
	u[l] = x0;
	v[l] = y0;
	w[l] = z0;
	color[l] = surface_inside_fast(surface, x0, y0, z0);
	l++;
      }

  FILE *f;
  f = stdout;
  fprintf(f, "# vtk DataFile Version 2.0\n"
	  "generated by %s\n"
	  "ASCII\n"
	  "DATASET STRUCTURED_POINTS\n"
	  "DIMENSIONS %d %d %d\n"
	  "ORIGIN %.16g %.16g %.16g\n"
	  "SPACING %.16g %.16g %.16g\n",
	  me, nx, ny, nz, lx, ly, lz, d, d, d);
  fprintf(f, "POINT_DATA %d\n", n);
  fputs("SCALARS c double\n", f);
  fputs("LOOKUP_TABLE default\n", f);
  for (i = 0; i < n; i++)
    fprintf(f, "%.16g\n", color[i]);

  FREE(u);
  FREE(v);
  FREE(w);
  FREE(color);
  y_fin(he, x, y, z);
  surface_fin(surface);
  return 0;
}

/*

make clean lint
9 time ./grid < /u/1.off > q
punto -c p
wc -l p
wc -l q

gnuplot -p <<'!'
plot "q" u 1:4, "p" u 1:4
!

diff p q

*/
