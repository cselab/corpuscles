#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <omp.h>
#include <real.h>
#include <co/argv.h>
#include <co/array.h>
#include <co/bbox.h>
#include <co/bi/cortez_zero.h>
#include <co/bi.h>
#include <co/err.h>
#include <co/f/garea.h>
#include <co/force.h>
#include <co/he.h>
#include <co/vec.h>
#include <co/macro.h>
#include <co/memory.h>
#include <co/util.h>
#include <co/surface.h>
#include <co/y.h>

#define FMT   CO_REAL_OUT

static const char *me = "rbc/velocity";
#define FMT_IN CO_REAL_IN
enum { X, Y, Z };
static He *he;
Surface *surface;
static int nv;
static int nx = 20;

static void
usg(void)
{
    fprintf(stderr, "%s [-n int] < OFF > VTK\n", me);
    exit(2);
}

int
main(__UNUSED int argc, char **argv)
{
    real *x, *y, *z;
    int i, j, k, l;
    real r[3];
    real *distance;
    int ny, nz, n;
    real lx, ly, lz, hx, hy, hz, Lx, Ly, Lz, dx, dy, dz;
    real *blo, *bhi;
    FILE *f;
    real margin[] = { 0.2, 0.2, 0.2 };
    Bbox *box;
    char *arg;

    while (*++argv != NULL && argv[0][0] == '-')
    switch (argv[0][1]) {
    case 'h':
      usg();
      break;
    case 'n':
      argv++;
      if ((arg = *argv) == NULL) {
        fprintf(stderr, "%s: -n needs an argument\n", me);
        exit(2);
      }
      nx = atoi(arg);
      if (nx <= 0) {
	  fprintf(stderr, "%s: nx=%d <= 0\n", me, nx);
	  exit(2);
      }
      break;
    default:
      fprintf(stderr, "%s: unknown option '%s'\n", me, argv[0]);
      exit(1);
    }
    
    y_inif(stdin, &he, &x, &y, &z);
    nv = he_nv(he);
    bbox_ini(&box);
    bbox_update(box, nv, x, y, z);
    bbox_lo(box, &blo);
    bbox_hi(box, &bhi);
    vec_sub(margin, blo);
    vec_add(margin, bhi);
    lx = blo[X];
    ly = blo[Y];
    lz = blo[Z];
    hx = bhi[X];
    hy = bhi[Y];
    hz = bhi[Z];
    bbox_fin(box);
    Lx = hx - lx;
    Ly = hy - ly;
    Lz = hz - lz;
    dx = nx == 0 ? 0 : Lx / nx;
    dy = dz = dx;
    ny = (int)(Ly/dy);
    nz = (int)(Lz/dz);
    MSG("nxyz: %d %d %d", nx, ny, nz);
    n = (nx + 1) * (ny + 1) * (nz + 1);
    MALLOC(n, &distance);
    real lo[2] = { -3, -3 }, hi[2] = { 3, 3 }, size = 0.25;
    surface_ini(lo, hi, size, &surface);
    surface_update(surface, he, x, y, z);
    for (l = k = 0; k <= nz; k++)
        for (j = 0; j <= ny; j++)
            for (i = 0; i <= nx; i++) {
                r[X] = lx + dx * i;
                r[Y] = ly + dy * j;
                r[Z] = lz + dz * k;
                surface_distance(surface, r[X], r[Y], r[Z], &distance[l++]);
            }
    f = stdout;
    fprintf(f, "# vtk DataFile Version 2.0\n"
            "generated by %s\n"
            "ASCII\n"
            "DATASET STRUCTURED_POINTS\n"
            "DIMENSIONS %d %d %d\n"
            "ORIGIN %.16g %.16g %.16g\n"
            "SPACING %.16g %.16g %.16g\n",
            me, nx + 1, ny + 1, nz + 1, lx, ly, lz, dx, dy, dz);
    fprintf(f, "POINT_DATA %d\n", n);
    fputs("SCALARS distance double\n", f);
    fputs("LOOKUP_TABLE DEFAULT\n", f);
    for (i = 0; i < n; i++)
        fprintf(f, FMT "\n", distance[i]);
    FREE(distance);
    surface_fin(surface);
    y_fin(he, x, y, z);
}
