find example/min/helfrich_xin_explore -name '[0-9]*.off' |
    awk -F / '
    BEGIN {
	r_float = "[+-]?([0-9]+[.]?[0-9]*|[.][0-9]+)([eE][+-]?[0-9]+)?"
	r_digits = "[0-9]+"
    }
    !/obsolete/ && !/orient/ && !/sergey/ {
	p = "example/min/helfrich_xin_explore/"
	gsub(/\//, "\\/", p)
	gsub(p, "")
	p_model($1)
	p_scheme($2)
	p_initial($3)
	# model c0 nt scheme kb vr initial_kv initial_vr tag
	p_da_vr($4)
	print model "\t" c0 "\t" scheme "\t" vr "\t" da "\t" tag "\t" $0
    }

    function p_model(s,   p) {
	if (ma(s, "ade", p = "ad") ||
	    ma(s, p = "bc") ||
	    ma(s, p = "CN") ||
	    ma(s, p = "C")) {
	    s = REST
	    if (eq(p, "CN")) {
		if (!ma(s, r_float))
		    err(sprintf("fail to parse CN \"%s\"", $0))
		model = "sc"
		c0 = -TOK
		s = REST
	    } else if (eq(p, "C")) {
		if (!ma(s, r_float))
		    err(sprintf("fail to parse C \"%s\"", s))
		model = "sc"
		c0 = TOK
		s = REST
	    } else {
		model = p
		c0 = "NaN"
	    }
	} else
	    err(sprintf("fail to model \"%s\"", $0))

	if (!ma(s, p = "_Nt"))
	    err(sprintf("fail to eat \"%s\" from \"%s\"", p, s))
	s = REST

	if (!ma(s, r_digits "$"))
	    err(sprintf("not digits \"%s\"", s))
	nt = TOK
    }

    function p_scheme(s,   p, t, i) {
	if (ma(s, "meyer_xin",   p = "D") ||
	    ma(s, "meyer_et_al", p = "D") ||
	    ma(s, "gompper_xin", p = "C") ||
	    ma(s, "juelicher", p = "B") ||
	    ma(s, "kantor_nelson", p = "A")) {
	    scheme = p
	    s = REST
	} else
	    err(sprintf("fail to parse scheme \"%s\"", $0))

	if (ma(s, p = "_Kb", t = "kb") ||
	    ma(s, p = "_Vr", t = "vr")) {
	    s = REST
	    if (!ma(s, r_float))
		err(sprintf("fail to parse Kb or Vr \"%s\"", $0))
	    s = REST
	    if (eq(t, "kb")) {
		kb = dot(TOK)
		vr = "[NaN]"
	    } else {
		kb = "NaN"
		vr = dot(TOK)
	    }
	} else
	    err(sprintf("fail to parse scheme \"%s\"", $0))

	# if (!empty(s))
	#    msg("[" s "]")
    }

    function p_initial(s,   p) {
	initial_kv = initial_vr = "NaN"

	if (ma(s, p = "sphere") ||
	    ma(s, p = "oblate") ||
	    ma(s, p = "prolate") ||
	    ma(s, p = "stomato")) {
	    initial = p
	    s = REST
	} else
	    err(sprintf("fail to parse initial \"%s\"", $0))

	if (eq(p, "stomato")) {
	    initial = "stomato"
	    if (!ma(s, p = "_Vr"))
		err(sprintf("fail to parse \"%s\"", $0))
	    s = REST
	    if (!ma(s, r_float))
		err(sprintf("fail to parse \"%s\"", $0))
	    initial_vr = TOK

	    if (ma(s, p = "_Kv")) {
		s = REST
		if (!ma(s, r_float))
		    err(sprintf("fail to parse \"%s\"", $0))
		initial_kv = TOK
	    }
	} else
	    initial = p
    }

    function p_da_vr(s) {
	da = tag = "NaN"
	if (!ma(s, r_float))
	    err(sprintf("fail to parse \"%s\"", $0))
	s = REST
	if (eq(model, "sc"))
	    vr = TOK
	else
	    da = TOK

	if (!empty(s)) {
	    if (!ma(s, "_"))
		err(sprintf("fail to parse \"%s\"", $0))
	    s = REST
	    tag = s
	}

    }

    function eq(a, b) { return "" a == "" b }
    function msg(s) { printf "%s\n", s | "cat >&2" }
    function err(s) { printf msg(s); exit(2) }

    function ma(s, r, ignore,   status) {
	status = match(s, "^" r)
	TOK  = substr(s, RSTART, RLENGTH)
	REST = substr(s, RSTART + RLENGTH)
	return status
    }

    function dot(s) {
	if (s !~ r_digits "$")
	    err(sprintf("not digits \"%s\"", s))
	sub(/^0/, "0.", s)
	return s
    }

    function empty(s) { return length(s) == 0 }
'
