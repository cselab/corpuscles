. he.util

prog=he.geomview0

usg () {
    msg "$prog"
    msg 'he geomview module'
    exit
}

if test $# -ne 0 && test "$1" = -h; then usg; fi

translate="$1"; shift
rotate="$1"; shift
fov="$1"; shift
output="$1"; shift	  
appearance="$1"; shift

"$AWK" -v prog="$prog" -v LOG="$LOG" \
       -v translate="$translate" -v rotate="$rotate" -v fov="$fov" -v appearance="$appearance" -v output="$output" '
function ini() {
    ARGC = 1
    off = ARGV[1]
    X = 1; Y = 2; Z = 3; W = 4
    KEY_Q = 113; KEY_S = 115; KEY_P = 112; KEY_SPACE = 32
    OK = 0; EOF = 1; ERR = -1
    split(translate, Translate)
    split(rotate,    Rotate)
}

function parse(s,   a, n) {
    n = sub(/^\(/, "", s)
    if (n != 1) return ERR
    n = sub(/\)$/, "", s)
    if (n != 1) return ERR
    n = split(s, a)
    if (a[1] == "rawevent")
       parse_key(a[2])
    return OK
}

function m_row(s, D, T,  a, i) {
    n = split(s, a)
    for (i = 1; i <= n; i++)
	T[D, i] = a[i]
}

function read_transform(T,   s) {
    g("write transform - worldgeom universe")
    if (getline s == ERR) err("fail to parse transform")
    if (s !~ /^transform {/)
	err(sprintf("expecting transform, got: `%s`", s))
    getline s; m_row(s, X, T)
    getline s; m_row(s, Y, T)
    getline s; m_row(s, Z, T)
    getline s; m_row(s, W, T)
    while (getline s != ERR && s !~ /[\t ]}/)  ;
}

function read_fov(  fov, n) {
    g("write camera - focus")
    if (getline s == ERR)
	err("fail to parse camera reply")
    if (s !~ /^camera {/)
	err(sprintf("expecting camera, got: `%s`", s))
    for (n = 1; n > 0; ) {
	if (getline == ERR)
	    err("fail to parse camera info")
	if (/{/) n++
	if (/}/) n--
	if (n == 0) break
	if (/[ \t]*fov[ \t]/) fov = $2
    }
    if (emptyp(fov))
	err("have not found fov")
    return fov
}

function write_command(T, fov,   tx, ty, tz, rx, ry, rz) {
    tx = T[W, X]; ty = T[W, Y]; tz = T[W, Z]
    rx = atan2(-T[Y,Z], T[Z,Z])
    ry = atan2(T[X,Z], sqrt(T[Y,Z]^2 + T[Z,Z]^2))
    rz = atan2(-T[X,Y], T[X,X])
    msg0(sprintf("-t %g %g %g -r %g %g %g -f %g", tx, ty, tz,
		 rad2ang(rx), rad2ang(ry), rad2ang(rz), fov))
}

function parse_key(k,   s,  T, fov) {
    if (k == KEY_Q) {
	read_transform(T)
	fov = read_fov()
	write_command(T, fov)
	g("exit")
    }
    else if (k == KEY_P) g("ui-panel geomview on")
    else if (k == KEY_S) {
	msg("write snap.ppm")
	g("snapshot Camera snap.ppm")
    } else if (k == KEY_SPACE) {
	read_transform(T)
	fov = read_fov()
	write_command(T, fov)
    } else err("unknown key: " k)
}

function key0(k) { g(sprintf("interest (rawevent %s)", k)) }
function key() {
    key0(KEY_Q)
    key0(KEY_S)
    key0(KEY_P)
    key0(KEY_SPACE)
}

function geom() {
    g("geometry obj appearance { : appearance } { : off }")
    g("bbox-draw obj no")
    if (eq(appearance, "-"))
	g("read appearance {define appearance { +edge } material {ks 0}}")
    else
	g(sprintf("read appearance { define appearance < `%s`}",
		  appearance))
}

function quote(s) { sub(/`/, "\"", s); sub(/`/, "\"", s); return s }
function g(s) { g0("(" s ")") }
function g0(s) {
    if ("" LOG != "0") msg("gcl: " quote(s))
    printf "%s\n", quote(s) | "cat"
    close("cat")
}

function m_ident(A,   i, j) {
    for (i = 1; i <= W; i++)
	for (j = 1; j <= W; j++)
	    A[i,j] = (i == j) + 0
}
function m_str(A,   i, j, s) {
    for (i = 1; (i, 1) in A; i++) {
	if (i > 1) s = s "\n"
	for (j = 1; (i, j) in A; j++) {
	    if (j > 0) s = s " "
	    s = s sprintf("%.16g", A[i,j])
	}
    }
    return s
}

function m_mult(A, B,   i, j, k, C) { # A *= B
    for (i = 1; (i, 1) in A; i++)
	for (j = 1; (i, j) in A; j++)
	    for (k = 1; (j, k) in B; k++)
		C[i,k] += A[i,j] * B[j,k]
    m_copy(C, A)
}

function m_copy(A, B,  k) { for (k in A) B[k] = A[k] }
function m_translate(x, y, z, A) { A[W,X] += x; A[W,Y] += y; A[W,Z] += z }
function m_rotate(x, y, z, A) { m_rotx(x, A); m_roty(y, A); m_rotz(z, A) }
function m_rotx(p, A,  T) { m_rot0(p, T, Y, Z); m_mult(A, T) }
function m_roty(p, A,  T) { m_rot0(p, T, Z, X); m_mult(A, T) }
function m_rotz(p, A,  T) { m_rot0(p, T, X, Y); m_mult(A, T) }
function m_rot0(p, A, P, Q,   c, s) {
    c = cos(p); s = sin(p)
    m_ident(A)
    A[P, P] = c; A[P, Q] = -s
    A[Q, P] = s; A[Q, Q] =  c
}

function transform(   A) {
    m_ident(A)
    m_rotate(ang2rad(Rotate[X]), ang2rad(Rotate[Y]), ang2rad(Rotate[Z]), A)
    m_translate(Translate[X], Translate[Y], Translate[Z], A)
    g("xform-set `worldgeom` transform {" m_str(A) "}")
}
function set_fov() {
    g(sprintf("merge camera focus {fov %s}", fov))
}

BEGIN {
    ini()
    key()
    transform()
    set_fov()    
    geom()
    g(sprintf("read geometry   { define off        < `%s` }", off))

    if (eq(output, "-")) {
	for (;;) {
	    if (getline s == ERR) break
	    if (parse(s) != OK) {
		msg("fail to parse: " s)
		break
	    }
	}
    } else {
	g(sprintf("snapshot Camera `%s`", output))
	g(sprintf("snapshot Camera `%s`", output)) # TODO
	g("exit")
    }
}
function msg(s)  { printf "%s: %s\n", prog, s | "cat >&2" }
function msg0(s) { printf "%s\n", s | "cat >&2" }

function err(s) { msg(s); g("exit") }
function emptyp(s) { return length(s) == 0 }
function ang2rad(s) { return pi()*s/180 }
function rad2ang(s) { return 180*s/pi() }
function pi() { return 3.141592653589793 }
function eq(a ,b) { return "" a == "" b }
' "$@"
