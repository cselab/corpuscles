. he.util

prog=he.vtk2off

usg () {
    msg "$prog"
    exit
}

if test $# -ne 0 && test "$1" = -h; then usg; fi

"$AWK" -v prog=$prog '
BEGIN {
    sc = "fx"
    Sc = !emptyp(sc)
}

{
    sub(/#.*/, "")
    if (!emptyp($0))
	L[++N] = $0
}

END {
    point()
    if (Sc) data()

    if (Sc) {
	map_color()
	write_color()
    }
    else write_black()
}

function tri_avg(t, a,   i, j, k) {
    i = t0[t]; j = t1[t]; k = t2[t]
    return (a[i] + a[j] + a[k])/3
}

function colormap(v, mi, ma,   r, g, b, d) {
   if (v < mi) v = mi
   if (v > ma) v = ma
   d = ma - mi
   v -= mi
   v /= d
   if (v < 1/4) {
       r = 0; g = 4*v; b = 1
   } else if (v < 1/2) {
       r = 0; g = 1; b = 2 - 4*v
   }
   else if (v < 3/4) {
       r = 4*v - 2; g = 1; b = 0
   } else {
       r = 1; g = 4 - 4*v; b = 0
   }
   R = r; G = g; B = b
}

function map_color(   i, mi, ma, e) {
    mi = ma = scalar[0]
    for (i = 0; i < nt; i++) {
	e = tri[i] = tri_avg(i, y)
	if (e > ma) ma = e
	if (e < mi) mi = e
    }
    for (i = 0; i < nt; i++) {
	e = tri[i]
	colormap(e, mi, ma)
	tri[i] = R " " G " " B
    }
}

function write_black(   i) {
    print "OFF"
    print nv, nt, ne = 0
    for (i = 0; i < nv; i++)
	print x[i], y[i], z[i]
    for (i = 0; i < nt; i++)
	print 3, t0[i], t1[i], t2[i]
}

function write_color(   i) {
    print "OFF"
    print nv, nt, ne = 0
    for (i = 0; i < nv; i++)
	print x[i], y[i], z[i]
    for (i = 0; i < nt; i++)
	print 3, t0[i], t1[i], t2[i], tri[i]
}

function point(   i) {
    while (++I <= N && L[I] !~ /^ASCII/) ;
    if (I > N)	err("not ascii vtk file")

    while (++I <= N && L[I] !~ /^DATASET[\t ]+POLYDATA/) ;
    if (I > N)	err("no DATASET POLYDATA")

    while (++I <= N && L[I] !~ /^POINTS/) ;
    if (I > N)	err("no POINTS")
    nv = idx(2)
    for (i = 0; i < nv; i++) {
	I++
	x[i] = idx(1)
	y[i] = idx(2)
	z[i] = idx(3)
    }
    while (++I <= N && L[I] !~ /^POLYGONS/) ;
    if (I > N)	err("no POLYGONS")
    nt = idx(2)

    for (i = 0; i < nt; i++) {
	I++
	t0[i] = idx(2)
	t1[i] = idx(3)
	t2[i] = idx(4)
    }
}

function data(   i) {
    for (;;) {
	if (++I > N) break
	if (L[I] ~ /^SCALARS/ &&
	    eq(idx(2), sc)) break
    }
    while (++I <= N && L[I] !~ /^LOOKUP_TABLE/) ;
    for (i = 0; i < nv; i++)
	scalar[i] = L[++I]
}

function idx(i,   a) {
    split(L[I], a)
    return a[i]
}
function msg(s)  { printf "%s: %s\n", prog, s | "cat >&2" }
function msg0(s) { printf "%s\n", s | "cat >&2" }
function err(s) { msg(s); exit(2) }
function emptyp(s) { return s ~ /^[\t ]*$/ }
function eq(a, b) { return "" a == "" b }
' "$@"
